// Generated by CoffeeScript 1.12.7
(function() {
  var Speaker, StreamPlayer, audioOptions, base, base1, events, fs, lame, loadNextSong, mpg123Util, request, self,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Speaker = require('speaker');

  lame = require('lame');

  request = require('request');

  events = require('events');

  fs = require('fs');

  mpg123Util = require('node-mpg123-util');

  if ((base = String.prototype).startsWith == null) {
    base.startsWith = function(s) {
      return this.slice(0, s.length) === s;
    };
  }

  if ((base1 = String.prototype).endsWith == null) {
    base1.endsWith = function(s) {
      return s === '' || this.slice(-s.length) === s;
    };
  }

  audioOptions = {
    channels: 2,
    bitDepth: 16,
    sampleRate: 44100,
    mode: lame.STEREO
  };

  self = null;

  StreamPlayer = (function(superClass) {
    extend(StreamPlayer, superClass);

    function StreamPlayer() {
      events.EventEmitter.call(this);
      self = this;
      this.queue = [];
      this.trackInfo = [];
      this.currentSong = null;
      this.playing = false;
      this.startTime = 0;
      this.speaker = null;
      this.speakerState = null;
      this.decoder = null;
      this.getVolume = 1;
      this.onNext = false;
    }

    StreamPlayer.prototype.play = function() {
      if (this.currentSong !== null) {
        return this.resume();
      } else if (this.queue.length > 0 && !this.playing) {
        this.getStream(this.queue[0], this.playStream);
        return this.queue.shift();
      } else if (this.playing) {
        return this.emit('error', 'already_playing');
      } else {
        return this.emit('error', 'empty_queue');
      }
    };

    StreamPlayer.prototype.pause = function(callback) {
      if (!this.playing) {
        if (callback) {
          return callback();
        }
        return;
      }
      this.speaker.removeAllListeners('close');
      this.speaker.end();
      return this.speaker.once('close', (function(_this) {
        return function() {
          _this.playing = false;
          _this.emit('paused', true);
          if (callback) {
            return callback();
          }
        };
      })(this));
    };

    StreamPlayer.prototype.resume = function() {
      if (this.playing) {
        return;
      }
      this.speaker = new Speaker(audioOptions);
      this.decoder.pipe(this.speaker);
      this.playing = true;
      this.emit('paused', false);
      return this.speaker.once('close', function() {
        return loadNextSong();
      });
    };

    StreamPlayer.prototype.next = function() {
      if (this.onNext) {
        return;
      }
      if (this.queue.length === 0) {
        this.emit('error', 'empty_queue');
        return;
      }
      this.onNext = true;
      return this.pause((function(_this) {
        return function() {
          _this.currentSong = null;
          return _this.play();
        };
      })(this));
    };

    StreamPlayer.prototype.remove = function(id) {
      var index;
      index = this.trackInfo.map(function(info) {
        return info.id;
      }).indexOf(parseInt(id, 10));
      this.trackInfo.splice(index, 1);
      return this.queue.splice(index, 1);
    };

    StreamPlayer.prototype.add = function(url, track) {
      this.queue.push(url);
      this.trackInfo.push(track);
      return this.emit('add', url, track);
    };

    StreamPlayer.prototype.volume = function(v) {
      if (v > 1) {
        v = 1;
      } else if (v < 0) {
        v = 0;
      }
      if (self.decoder && self.decoder.mh) {
        mpg123Util.setVolume(self.decoder.mh, v);
      }
      return this.getVolume = v;
    };

    StreamPlayer.prototype.nowPlaying = function() {
      if (this.playing) {
        return {
          track: this.currentSong,
          timestamp: this.startTime
        };
      } else {
        return false;
      }
    };

    StreamPlayer.prototype.isPlaying = function() {
      return this.playing;
    };

    StreamPlayer.prototype.getQueue = function() {
      return this.trackInfo;
    };

    StreamPlayer.prototype.getStream = function(url, callback) {
      var stream;
      if (url.startsWith('http')) {
        return request.get(url).on('response', function(res) {
          if (res.headers['content-type'] === 'audio/mpeg') {
            return callback(res);
          } else {
            self.emit('invalid url', url);
            return loadNextSong();
          }
        });
      } else {
        stream = fs.createReadStream(url);
        return callback(stream);
      }
    };

    StreamPlayer.prototype.playStream = function(stream) {
      self.decoder = new lame.Decoder();
      self.speaker = new Speaker(audioOptions);
      return stream.pipe(self.decoder).once('format', function() {
        mpg123Util.setVolume(self.decoder.mh, self.getVolume);
        self.decoder.pipe(self.speaker);
        self.startTime = Date.now();
        self.playing = true;
        self.currentSong = self.trackInfo.shift();
        self.emit('paused', false);
        self.emit('playing', self.currentSong);
        self.onNext = false;
        return self.speaker.once('close', function() {
          return loadNextSong();
        });
      });
    };

    return StreamPlayer;

  })(events.EventEmitter);

  loadNextSong = function() {
    self.playing = false;
    self.emit('paused', true);
    self.emit('ended', self.currentSong);
    return self.next();
  };

  module.exports = StreamPlayer;

}).call(this);
